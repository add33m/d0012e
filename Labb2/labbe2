

def divConSum(list):
    if len(list) == 1:
        # Hardcoded insertionsort for n = 3

        maxsum = list[0]
        currentsum = list[0]
        currentsum2 = list[0]
        return currentsum, maxsum, currentsum2
        

    mid = len(list) // 2
    a1, max1, b1  = divConSum(list[:mid])
    a2, max2, b2 = divConSum(list[mid:])

    #counting out the biggest maximum number we currently have
    if max2 > max1:
        max1 = max2

    print ("a1 = ", a1, "and a2 = ", a2)

    if a1 > 0:
        if  a1 + b2 > 0:
            currentsum = a1 + b2
            print("we are merging ", b1, " with ", b2)
            currentsum2 = b1 + b2
            #here we will save the sum of the two arrays as our new max value if it is greater than our current max value
            if currentsum > max1:
                max1 = currentsum
        else:
            #the subarray cant continue as a2 turns it into a net-loss meaning it is better to just start over.
            currentsum = 0
            currentsum2 = 0
            print("list reset")
    elif a2 > 0:
        currentsum = a2
        currentsum2 = a1+b2
        print("we merge ", a1, "and ", b2)
    else:
        currentsum = 0
        currentsum2 = 0

    print("Current max value: ", max1)
   
    #counting out the largest max sum we have (can become lesser as long as sum is still positive)
    return currentsum, max1, currentsum2
    
        
    
    # Return output converted to tuple
    return tuple(output)

#testlist = [16, -17, 6, -2, 19, -18, 4, 1, 15, -1, -1, -1, -1, -1, -1, 1]
#testlist = [1, -3, 79, 5, -1, 80,2, 9]
#testlist = [-1, -1, -1, 10, -5, 10, -1, -1]
print("The biggest sum is:  ", divConSum(testlist)[1])